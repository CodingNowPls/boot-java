# 若依系统单租户扩展为多租户的大体方案



### 基本方案

*   将`ruoyi-vue`扩展为多租户，查看了下其生态中也有一些多租户的扩展，感觉都有些简单，不太完善，所以并没有采用。
*   多租户实现方式只用了最简单的表中添加字段标识`tenant_id`的方式来实现多租户，其他单独数据库、独立表等方式未涉及。
*   采用的`mybatis-plus`提供的多租户方案，也测试过最近新的`mybatis-flex`类库，但是它不支持原生xml语句自动拼接租户字段，而`mybatis-plus`则支持。相关文档：[mybatis-plus文档](https://baomidou.com/pages/2976a3/#innerinterceptor)、[RuoYi集成mybatis-plus文档](http://doc.ruoyi.vip/ruoyi-vue/document/cjjc.html#%E9%9B%86%E6%88%90mybatisplus%E5%AE%9E%E7%8E%B0mybatis%E5%A2%9E%E5%BC%BA)、[冲突解决](https://gitee.com/y_project/RuoYi-Vue/issues/I81013#note_22049201_link)
*   是否有管理后台，看到有一些案例并没有一个总的管理后台，而是其中一个租户有这些管理权限，但这样感觉权限不太好划分，目前采用区分管理后台和业务后台，用户登录时可切换选择哪个后台来登录。
*   登录时一般有两种方式，目前采用了第二种方式：
    *   一种是登录界面就选择租户，此时用户表一般就要增加租户标识。
    *   一种是登录界面不需要选择租户，登录后自动登录上次的租户，然后可以在后台中切换不同租户，这样的话用户表就是共用的，然后有一个用户和租户关系表来维护他们之间的关系。

### 整体框架

后台登录分为`管理后台登录`和`业务后台登录`，两者的功能及菜单规划如下图，红色为`管理后台登录`后展示的功能，绿色为`业务后台登录`后展示的功能，其中组织机构就是租户的概念，下面介绍下于原有系统大概的变更：

![Image 12](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095522023-142440136.png)

*   菜单表 sys_menu
    
    *   不需要增加租户标识字段，而是依赖`sys_role_menu`角色菜单表来展示不同的菜单。
    *   增加`is_sys`标识，只用于最顶层的菜单，为`1`标识这个菜单只展示在管理后台中，为`2`标识这个菜单只展示在租户业务后台中，不允许一个菜单既是管理后台的有时业务后台的，如存在此情况，新建不同的菜单来区分。
    *   菜单列表展示所有的菜单，包含后台管理和业务的，且可以修改。
    *   后台管理设置角色权限时只展示`is_sys`为`1`的菜单。
    *   后台管理设置租户菜单套餐时只展示`is_sys`为`2`的菜单
*   用户表 sys_user
    
    *   增加`is_sys`标识，只有为`1`的用户才能登录管理后台，管理后台中创建新用户时可以选择。
    *   增加`is_admin`标识，只有为`1`的用户才能登录业务后台，业务后台中创建新用户时可以选择。
    *   增加`sys_tenant`关联表，用于标识用户和租户的关系。
    *   管理后台的用户管理展示全部的用户，用户可以选择分配到哪个租户中，无部门选择，可以选择后台管理的角色。
    *   业务后台的用户管理展示此租户下的用户，有部门，且可以选择租户下的角色。
*   部门表 sys_dept
    
    *   增加租户标识字段
    *   管理后台取消部门相关功能（目前我的项目是这样，如果管理后台也想要部门的话可以用租户ID为`0`的来标识，但相关逻辑也要处理）
    *   部门管理只在租户内才存在。
*   角色表 sys_role
    
    *   增加租户标识字段
    *   增加`is_admin`字段标识是否为管理员，而不是用是否为`admin`来标识，而且此管理员既可以标识管理后台的管理员也可以标识租户后台的管理员。
    *   管理后台的角色管理展示管理后台的角色，内部实现是用租户ID为0的代表管理后台的角色。
    *   业务后台的角色管理展示的是业务后台的角色。
*   用户登录
    
    *   前端页面`login.vue`复制一个`login-admin.vue`，用来区分管理后台登录和租户业务后台登录，两个页面增加个按钮可以互相切换。
    *   两个页面传递一个参数`isAdminLogin`来区分管理登录还是业务登录，然后在`loadUserByUsername`方法中判定逻辑。
        *   如果是后台管理登录则判定用户的`is_sys`标识是否为`1`，只有此标识才能登录管理后台
        *   如果是后台业务登录，则从人员租户表中判定是否属于某个租户，如果不属于则报错，如果属于，则优先取上次登录的机构，无上次登录机构则取第一个机构，登录后可自行切换不同的租户。
        *   上述两个登录区分不同的部门、角色信息，存入`LoginUser`信息中。
    *   前端不需要在所有请求的`header`中增加类似`TENANT-ID`的字段，只需要在登录后将租户ID放到`LoginUser`中即可，然后请求用户信息时可以将当前登录的租户返回，方便展示当前的租户，而`mybatis-plus`多租户中配置多租户的方法`getTenantId`中直接从`SecurityUtils`中获取当前租户的ID即可。
*   租户管理
    
    *   只存在管理后台中。
    *   菜单包，可以设置不同的菜单包。
    *   租户管理，可以创建租户，然后还有两个主要操作
        *   可以分配不同的菜单包，同时系统会设置默认的租户管理员角色，管理员角色管理的关联菜单就是分配的菜单包。
        *   可以设置管理员，上方分配菜单同时创建默认的管理员角色，此时分配管理员就是将此角色可此租户内的某个人员关联，此人就有了租户管理员角色。
*   缓存处理
    
    *   主要要处理`redis`中用户信息的缓存。
    *   总菜单
        *   新增无影响，需要手动将相关角色、或菜单包赋值新菜单。
        *   中修改无影响，因为是通过ID来展示菜单。
        *   删除需要先判定是否有分配角色，有则不能删除。新增无影响
    *   菜单包
        *   新增，无影响
        *   修改，又分为菜单的新增和删除：
            *   菜单新增，只增加关联此套餐下的租户管理员角色下的新增菜单，且更新在线的租户管理员的缓存，租户下其他人员再由租户管理员手动分配
            *   菜单删除，删除关联此套餐下的所有角色下的此菜单，且更新在线的所有用到上方角色的人员的缓存。
        *   删除，判定此菜单包是否有分配，有则不允许删除
    *   租户菜单包 分配
        *   新增，只增加此租户下的管理员角色，将新增菜单包的菜单关联写入，且更新在线的此租户管理员缓存。
        *   删除，删除关联此菜单包下的所有角色下的此菜单，且更新在线的所有用到上方角色的人员的缓存。
    *   管理后台中的人员更新，则需要更新包含管理和业务此在线人员的缓存
    *   业务后台中的人员更新，则只需要更新此租户下的在线人员的缓存。

### 示意图

*   登录，可切换管理和业务两种登录方式：
    
    ![Image 13](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095538162-611291098.gif)
    
*   管理后台用户，可以分配所属租户，可以区分是否有管理后台登录权限，系统用户还可以选择系统角色：
    
    ![Image 14](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095616731-1444848244.gif)
    
*   管理后台菜单和权限，菜单列表展示的是全部菜单，然后区分哪些是属于管理后台哪些是属于租户后台，然后角色这里是指管理后台的角色，所以只展示了管理后台的菜单：
    
    ![Image 15](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095637141-1054835924.gif)
    
*   管理后台租户管理，可以配置菜单套餐，此套餐只取`is_sys`为0的菜单，然后机构可以分配菜单包和指定管理员：
    
    ![Image 16](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095646494-899338005.gif)
    
*   租户业务后台用户登录，登录后只展示租户菜单，且可以切换不同租户，不同租户的权限及菜单也不相同：
    
    ![Image 17](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095653476-1591244495.gif)
    
*   租户业务后台的租户用户，只展示此租户内的用户且会关联部门，关联的角色也为此租户内的角色，如果创建，实际上是既创建一个总的用户，然后又创建了一个用户和本租户的关系，而删除则只移除与此租户关系，而不能删除用户：
    
    ![Image 18](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095703159-576901163.gif)
    
*   租户业务后台的租户角色，只用于此租户内的角色，用管理员所具有的菜单做为此租户总的菜单：
    
    ![Image 19](https://img2023.cnblogs.com/blog/922535/202311/922535-20231128095710831-2095709148.gif)
    
*   部门和岗位，就是用原有的部门和岗位，只不过是放到租户中了且支持多租户，就不演示了。
    

### 代码示例

*   `mybatis-plus`多租户配置：
    
    *   参数配置
        
        ```java
        package com.ruoyi.framework.config.properties;
        
        import lombok.Data;
        import org.springframework.boot.context.properties.ConfigurationProperties;
        import org.springframework.context.annotation.Configuration;
        
        import java.util.List;
        
        /**
         * 多租户配置
         *
         * @author vishun
         */
        @Configuration
        @ConfigurationProperties(prefix = "tenant")
        @Data
        public class TenantProperties {
        
            /**
             * 是否开启多租户
             */
            private Boolean enable;
        
            /**
             * 租户字段名
             */
            private String column;
        
            /**
             * 需要忽略的租户表名
             */
            private List<String> excludes;
        
        }
        ```
        
        ```yml
        tenant:
          # 是否启用，仅测试时可以临时关闭整个租户机制，但因为整个框架都是多租户架构，所以正式环境必须要启用
          enable: true
          # 租户字段名
          column: tenant_id
          # 排除表
          excludes:
            - sys_tenant #租户表
            - sys_menu_pack #所有的菜单包
            - sys_menu_pack_detail # 租户菜单包含的菜单详情
            - sys_tenant_menu_pack # 租户分配的菜单包
            - gen_table
            - gen_table_column
            - qrtz_blob_triggers
            - qrtz_calendars
            - qrtz_cron_triggers
            - qrtz_fired_triggers
            - qrtz_job_details
            - qrtz_locks
            - qrtz_paused_trigger_grps
            - qrtz_scheduler_state
            - qrtz_simple_triggers
            - qrtz_simprop_triggers
            - qrtz_triggers
            - sys_config
            - sys_dict_data
            - sys_dict_type
            - sys_job
            - sys_job_log
            - sys_logininfor
            - sys_menu
            - sys_notice
            - sys_oper_log
            - sys_role_dept
            - sys_role_menu
            - sys_user
            - sys_user_post
            - sys_user_role
        ```
        
    *   拦截器配置`MybatisPlusConfig`类中
        
        ```java
            @Autowired
            private TenantProperties tenantProperties;
        
            /**
             * mybatis拦截器
             *
             * @return
             */
            @Bean
            public MybatisPlusInterceptor mybatisPlusInterceptor() {
                MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
                //多租户插件
                if (tenantProperties.getEnable()) {
                    interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new TenantLineHandler() {
                        /**
                         * 获取租户ID
                         *
                         * @return
                         */
                        @Override
                        public Expression getTenantId() {
                            //从登录信息中获取当前组织ID
                            Long tenantId = SecurityUtils.getCurrentTenantIdWithoutException();
                            if (tenantId == null) {
                                return new NullValue();
                            }
                            return new LongValue(tenantId);
                        }
        
                        /**
                         * 获取租户字段的名称
                         *
                         * @return
                         */
                        @Override
                        public String getTenantIdColumn() {
                            return tenantProperties.getColumn();
                        }
        
                        /**
                         * 哪些表忽略租户
                         *
                         * @param tableName 表名
                         * @return true忽略，false开启
                         */
                        @Override
                        public boolean ignoreTable(String tableName) {
                            List<String> excludeTables = tenantProperties.getExcludes();
                            if (excludeTables != null && !excludeTables.isEmpty() && excludeTables.contains(tableName)) {
                                return true;
                            }
                            return false;
                        }
                    }));
                }
                // 分页插件
                interceptor.addInnerInterceptor(paginationInnerInterceptor());
                // 乐观锁插件
                interceptor.addInnerInterceptor(optimisticLockerInnerInterceptor());
                // 阻断插件
                interceptor.addInnerInterceptor(blockAttackInnerInterceptor());
                return interceptor;
            }
        ```
    
*   登录处理，`UserDetailsServiceImpl`类中的登录方法：
    
    ```java
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            try {
                //此时还没有租户，所以全部关闭租户功能
                InterceptorIgnoreHelper.handle(IgnoreStrategy.builder().tenantLine(true).build());
                //后续逻辑
                SysUser user = userService.selectUserByUserName(username);
                if (StringUtils.isNull(user)) {
                    log.info("登录用户：{} 不存在.", username);
                    throw new ServiceException("登录用户：" + username + " 不存在");
                } else if (UserStatus.DELETED.getCode().equals(user.getDelFlag())) {
                    log.info("登录用户：{} 已被删除.", username);
                    throw new ServiceException("对不起，您的账号：" + username + " 已被删除");
                } else if (UserStatus.DISABLE.getCode().equals(user.getStatus())) {
                    log.info("登录用户：{} 已被停用.", username);
                    throw new ServiceException("对不起，您的账号：" + username + " 已停用");
                }
                //修改只有后台登录才验证，其它微信登录等没有密码不需要验证
                Authentication usernamePasswordAuthenticationToken = AuthenticationContextHolder.getContext();
                String loginUserType = AuthenticationContextHolder.getLoginUserType();
                if (usernamePasswordAuthenticationToken != null && LoginUserType.SYS_USER.getCode().equals(loginUserType)) {
                    passwordService.validate(user);
                }
                Long userId = user.getUserId();
                 //后台管理登录时，默认为0
                Long currentTenantId = Constants.ADMIN_DEFAULT_TENANT_ID;
                //区分管理登录和业务登录
                Boolean isAdminLogin = AuthenticationContextHolder.getIsAdminLogin();
                isAdminLogin = isAdminLogin != null && isAdminLogin;
                if (isAdminLogin) {
                    //如果是管理后台登录，额外判定
                    if (SysYesNo2.NO.equals(user.getIsSys())) {
                        log.info("登录用户：{} 非管理用户.", username);
                        throw new ServiceException("对不起，您的账号：" + username + " 并非管理账号");
                    }
                } else {
                    //判定是否存在租户，且设置默认租户
                    BaseUserTenant queryUserTenant = new BaseUserTenant();
                    queryUserTenant.setUserId(userId);
                    queryUserTenant.setDisabled(SysNormalDisable.NORMAL);
                    List<BaseUserTenant> list = systemTenantService.selectUserTenantList(queryUserTenant);
                    if (list == null || list.isEmpty()) {
                        log.info("登录用户：{} 无归属机构.", username);
                        throw new ServiceException("对不起，您的账号：" + username + " 无归属机构");
                    }
                    //优先使用上次的租户，如果不存在，则取第一个
                    List<Long> tenantIds = list.stream().map(BaseUserTenant::getTenantId).collect(Collectors.toList());
                    Long lastTenantId;
                    if (LoginUserType.SYS_USER.getCode().equals(loginUserType)) {
                        //如果是后端
                        lastTenantId = user.getBackendLoginTenantId();
                    } else {
                        //如果是前端，我们系统有移动端，所以额外处理了下
                        lastTenantId = user.getFrontendLoginTenantId();
                    }
                    if (lastTenantId > 0 && tenantIds.contains(lastTenantId)) {
                        currentTenantId = lastTenantId;
                    } else {
                        currentTenantId = tenantIds.get(0);
                    }
                }
                //组装部门、角色等信息，管理和业务端也是不一样的
                user = userService.getLatestUser(user, isAdminLogin, userId, currentTenantId);
                //返回
                return new LoginUser(user, loginUserType, currentTenantId, isAdminLogin, permissionService.getMenuPermission(user));
            } finally {
                //恢复租户功能
                InterceptorIgnoreHelper.clearIgnoreStrategy();
            }
        }
    ```
    

### 总结

*   以上只是大体的概述和示例，实际上还有非常多的前后端变动处理，仅供参考。

